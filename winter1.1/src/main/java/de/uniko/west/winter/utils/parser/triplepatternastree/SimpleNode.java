/*

The WINTER-API is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The WINTER-API is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the WINTER-API.  If not, see <http://www.gnu.org/licenses/>.

*/

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package de.uniko.west.winter.utils.parser.triplepatternastree;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.uniko.west.winter.utils.parser.triplepatternparser.SPARQLPatternParser;
import de.uniko.west.winter.utils.parser.triplepatternparser.SPARQLPatternParserTreeConstants;
import de.uniko.west.winter.utils.parser.triplepatternparser.SPARQLPatternParserVisitor;
import de.uniko.west.winter.utils.parser.triplepatternparser.VisitorException;

public class SimpleNode implements Node{
	
  protected static transient Logger logger = LoggerFactory.getLogger(SimpleNode.class.getName());
	
  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected SPARQLPatternParser parser;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(SPARQLPatternParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }
  
  public void jjtRemoveChild(Node node) throws VisitorException{
	  logger.debug("Removing child {} from {} with {} children",new Object[]{node, this, children.length});
	  for (int i = 0; i < jjtGetNumChildren(); i++){
			if (node.equals(children[i])){				
				children = jjtRemoveChild(i);
				break;
			}
		}
	}
  
  public Node[] jjtRemoveChild(int i) throws VisitorException{
	 logger.debug("Found Node at position {} removing...", i);
	 logger.debug("should have {} children", children.length -1);
	 Node[] c = new Node[children.length - 1];
	 if (i == 0){
		System.arraycopy(children, 1, c, 0, c.length); 
	 }else if(i == children.length-1){
		System.arraycopy(children, 0, c, 0, c.length);
	 }else{
		 // Copy Head from 0 to pos-1
		 logger.debug("Copying from {}, {} #Elements",0 , i);
		 System.arraycopy(children, 0, c, 0, i);
		 // copy tail from pos+1 to end
		 logger.debug("Copying from {}, {} #Elements",i+1 , (children.length - ( i-1 )));
		 System.arraycopy(children, i+1, c, i, (children.length - ( i+1 )));
	 }
	 return c;
  }

  public void jjtReplaceChild(Node node, Node replacement) throws VisitorException{
	  if(!node.getClass().equals(replacement.getClass())) throw new VisitorException("Can only replace objects of same type");
	  for (int i = 0; i < jjtGetNumChildren(); i++){
		  if (node.equals(children[i])){
			  children[i] = replacement;
		  }
	  }
  }
  
  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  /** Accept the visitor. **/
  public Object jjtAccept(SPARQLPatternParserVisitor visitor, Object data)
     throws VisitorException {
    return visitor.visit(this, data);
  }

  /** Accept the visitor. **/
  public Object childrenAccept(SPARQLPatternParserVisitor visitor, Object data)
     throws VisitorException {
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        children[i].jjtAccept(visitor, data);
      }
    }
    return data;
  }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() { return SPARQLPatternParserTreeConstants.jjtNodeName[id]; }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public String dumpToString(boolean samePredicateFlag, boolean sameSubjectFlag) {
	  String dump = "";
	  if(children != null){
		  for (int i = 0; i < children.length; ++i) {
			  SimpleNode n = (SimpleNode)children[i];
			  if(n != null) {
				  dump += n.dumpToString(samePredicateFlag, sameSubjectFlag);
			  }
		  }
	  }
//	  logger.debug("Dumping {} ", dump);
	  return dump;
  }
  
  @Override
  public SimpleNode jjtClone(){
	logger.debug("Cloning {}", this);
	SimpleNode clone =  new SimpleNode(this.id);
	logger.debug("Setting Parent {}", this.parent);
	clone.jjtSetParent(this.parent);
	clone.value = this.value;
	clone.parser = this.parser;
	if (children != null){
		logger.debug("{} children found for {} cloning them", children.length, this);
		for (int i = 0; i < children.length; i++){
			logger.debug("Cloning {} child {}", i, children[i]);
			Node childClone = children[i].jjtClone();
			clone.jjtAddChild(childClone, i);
		}
	}else logger.debug("No children found for {}", this);
	return clone;
	  
  }
  
  /**
   * Clone just a node without children and parent
   * @return
   * 		SimpleNode without children and parent
   */
  @Override
  public SimpleNode jjtFlatClone(){
	logger.debug("Flat cloning {}", this);
	SimpleNode clone = new SimpleNode(this.id);
	clone.value = this.value;
	clone.parser = this.parser;
	return clone;
  }

  @Override
  public boolean jjtCompareTo(Node node) {
	boolean result;
	SimpleNode simpleNode = null;
	if(this.getClass()==node.getClass()){
		simpleNode = (SimpleNode)node;
		if(this.jjtGetValue().getClass()==simpleNode.jjtGetValue().getClass() &&
				this.jjtGetNumChildren()==simpleNode.jjtGetNumChildren()){
			if(this.jjtGetNumChildren()!=0){
				for(int i = 0;i<this.jjtGetNumChildren();i++){
					result = this.jjtGetChild(i).jjtCompareTo(simpleNode.jjtGetChild(i));
					if(result){
						continue;
					} else
						return false;
				}
				return true;
			} else
				return true;
		} else 
			return false;
	} else
		return false;
  }
  @Override
  public boolean isLastChild(ASTIRI node) {
	  if (children[children.length -1].equals(node)) return true;
	  return false;
  }
  
}

/* JavaCC - OriginalChecksum=786fe1315c1ebfb060f5f56a4b68fa9c (do not edit this line) */
