/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. TriplePatternParser.jj */
/*@egen*/// SPARQL Pattern Syntax inspired by the W3C SPARQL definition found on
// http://www.w3.org/TR/rdf-sparql-query/
// Token and Grammar insprirend by the Sesame sparql.jj written by Arjohn Kampman
// Copyright Aduna (http://www.aduna-software.com/) (c) 1997-2007.
// Licensed under the Aduna BSD-style license

// Author:  Stefan Scheglmann schegi@uni-koblenz.de

options
{
}

PARSER_BEGIN(SPARQLPatternParser)

package de.west.winter.utils.triplepatternparser ;

import java.io.StringReader;
import java.net.URI;
import de.west.winter.utils.RDF;
import de.west.winter.utils.XMLSchema;

public class SPARQLPatternParser/*@bgen(jjtree)*/implements SPARQLPatternParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTSPARQLPatternParserState jjtree = new JJTSPARQLPatternParserState();

/*@egen*/
	public static ASTQueryContainer parsePattern (String pattern) throws TokenMgrError, ParseException	{
	  	SPARQLPatternParser spp = new SPARQLPatternParser(new StringReader(pattern));
	  	return spp.QueryContainer();	}

	private static String _trimString(String s, int n) {
	  if (s.length() >= 2) {
	    s = s.substring(n, s.length() - n);
	  }
	  return s;
	}
}

PARSER_END(SPARQLPatternParser)

ASTQueryContainer QueryContainer():
{/*@bgen(jjtree) QueryContainer */
  ASTQueryContainer jjtn000 = new ASTQueryContainer(JJTQUERYCONTAINER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QueryContainer */
    try {
/*@egen*/
    TriplesBlock() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


// Tokens

TOKEN :
{
    // Whitespace characters
    <#WS_CHAR: " " | "\t" | "\n" | "\r" | "\f">
}

SKIP :
{
    <WHITESPACE: <WS_CHAR>>
}

SPECIAL_TOKEN :
{
    <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])*>
}

// Special characters
TOKEN :
{
    <LPAREN: "(">
|   <RPAREN: ")">
|   <LBRACE: "{">
|   <RBRACE: "}">
|   <LBRACK: "[">
|   <RBRACK: "]">
|   <SEMICOLON: ";">
|   <COMMA: ",">
|   <DOT: ".">
|   <EQ: "=">
|   <NE: "!=">
|   <GT: ">">
|   <LT: "<">
|   <LE: "<=">
|   <GE: ">=">
|   <NOT: "!">
|   <OR: "||">
|   <AND: "&&">
|   <PLUS: "+">
|   <MINUS: "-">
|   <STAR: "*">
|   <SLASH: "/">
|   <DT_PREFIX: "^^">
|   <NIL: <LPAREN> (<WS_CHAR>)* <RPAREN>>
|   <ANON: <LBRACK> (<WS_CHAR>)* <RBRACK>>
}

TOKEN :
{
    <IS_A: "a"> // Note: case-sensitive!
}

TOKEN [IGNORE_CASE] :
{
    <BASE: "base">
|   <PREFIX: "prefix">
|   <SELECT: "select">
|   <CONSTRUCT: "construct">
|   <DESCRIBE: "describe">
|   <ASK: "ask">
|   <DISTINCT: "distinct">
|   <REDUCED: "reduced">
|   <FROM: "from">
|   <NAMED: "named">
|   <WHERE: "where">
|   <ORDER: "order">
|   <BY: "by">
|   <ASC: "asc">
|   <DESC: "desc">
|   <LIMIT: "limit">
|   <OFFSET: "offset">
|   <OPTIONAL: "optional">
|   <GRAPH: "graph">
|   <UNION: "union">
|   <FILTER: "filter">
|   <STR: "str">
|   <LANG: "lang">
|   <LANGMATCHES: "langmatches">
|   <DATATYPE: "datatype">
|   <BOUND: "bound">
|   <SAMETERM: "sameTerm">
|   <IS_IRI: ("isIRI"|"isURI")>
|   <IS_BLANK: "isBlank">
|   <IS_LITERAL: "isLiteral">
|   <REGEX: "regex">
|   <TRUE: "true">
|   <FALSE: "false">
}

TOKEN:
{
    <Q_IRI_REF: "<" (~["<", ">", "\"", "{", "}", "|", "^", "`", "\\", "\u0000"-" "])* ">">

|   <PNAME_NS: (<PN_PREFIX>)? ":">
|   <PNAME_LN: (<PN_PREFIX>)? ":" <PN_LOCAL>> // Note: PN_LOCAL not optional, case handled by PNAME_NS

|   <BLANK_NODE_LABEL: "_:" <PN_LOCAL>>

|   <VAR1: "?" <VARNAME>>
|   <VAR2: "$" <VARNAME>>
|   <LANGTAG: "@" (<ALPHA>)+ ("-" (<ALPHA>|<NUM>)+)*>
|   <INTEGER: (<NUM>)+>
|   <INTEGER_POSITIVE: "+" <INTEGER>>
|   <INTEGER_NEGATIVE: "-" <INTEGER>>
|   <DECIMAL: (<DECIMAL1>|<DECIMAL2>)>
|   <#DECIMAL1: (<NUM>)+ "." (<NUM>)*>
|   <#DECIMAL2: "." (<NUM>)+>
|   <DECIMAL_POSITIVE: "+" <DECIMAL>>
|   <DECIMAL_NEGATIVE: "-" <DECIMAL>>
|   <DOUBLE: (<DOUBLE1>|<DOUBLE2>|<DOUBLE3>)>
|   <#DOUBLE1: (<NUM>)+ "." (<NUM>)* <EXPONENT>>
|   <#DOUBLE2: "." (<NUM>)+ <EXPONENT>>
|   <#DOUBLE3: (<NUM>)+ <EXPONENT>>
|   <#EXPONENT: ["e","E"] (["+","-"])? (<NUM>)+>
|   <DOUBLE_POSITIVE: "+" <DOUBLE>>
|   <DOUBLE_NEGATIVE: "-" <DOUBLE>>
|   <STRING_LITERAL1: "'" (<SAFE_CHAR1>|<ECHAR>)* "'">
|   <STRING_LITERAL2: "\"" (<SAFE_CHAR2>|<ECHAR>)* "\"">
|   <STRING_LITERAL_LONG1: "'''" ( ("'"|"''")? (<SAFE_CHAR_LONG1>|<ECHAR>) )* "'''">
|   <STRING_LITERAL_LONG2: "\"\"\"" ( ("\""|"\"\"")? (<SAFE_CHAR_LONG2>|<ECHAR>) )* "\"\"\"">
|   <#SAFE_CHAR1: (~["'", "\\", "\r", "\n"])>
|   <#SAFE_CHAR2: (~["\"", "\\", "\r", "\n"])>
|   <#SAFE_CHAR_LONG1: (~["'","\\"])>
|   <#SAFE_CHAR_LONG2: (~["\"","\\"])>
|   <#ECHAR: "\\" ["t", "b", "n", "r", "f", "\\", "\"", "'"]>
|   <#HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
|   <#ALPHA: ["a"-"z","A"-"Z"]>
|   <#NUM: ["0"-"9"]>
}

TOKEN:
{
    <#PN_CHARS_BASE:
        <ALPHA> | ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"] | ["\u00f8"-"\u02ff"] | ["\u0370"-"\u037d"]
      | ["\u037f"-"\u1fff"] | ["\u200c"-"\u200d"] | ["\u2070"-"\u218f"] | ["\u2c00"-"\u2fef"]
      | ["\u3001"-"\ud7ff"] | ["\uf900"-"\ufdcf"] | ["\ufdf0"-"\ufffd"]
      // | ["\u10000"-"\uefffF"] FIXME: JavaCC/Java can't handle this?
    >
|   <#PN_CHARS_U: <PN_CHARS_BASE> | "_">
|   <#PN_START_CHAR: <PN_CHARS_U> | <NUM>>
|   <#VAR_CHAR: <PN_START_CHAR> | "\u00b7" | ["\u0300"-"\u036f"] | ["\u203f"-"\u2040"]>
|   <#PN_END_CHAR: <VAR_CHAR> | "-">
|   <#PN_CHAR: <PN_END_CHAR> | ".">

|   <#PN_PREFIX: <PN_CHARS_BASE> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|   <#PN_LOCAL: <PN_START_CHAR> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|   <#VARNAME: <PN_START_CHAR> (<VAR_CHAR>)*>
}

void TriplesBlock()       :
{}
{
    // Note: recursive rule rewriten to non-recursive rule, requires lookahead
    TriplesSameSubject() ( LOOKAHEAD(2) <DOT> TriplesSameSubject() )* [<DOT>]
}

void TriplesSameSubject() :
{/*@bgen(jjtree) TriplesSameSubject */
  ASTTriplesSameSubject jjtn000 = new ASTTriplesSameSubject(JJTTRIPLESSAMESUBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TriplesSameSubject */
    try {
/*@egen*/
    VarOrTerm() PropertyList()
|
    TriplesNode() [PropertyList()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarOrTerm()       :
{}
{
    Var()
|
    GraphTerm()
}

void PropertyList() :
{/*@bgen(jjtree) PropertyList */
  ASTPropertyList jjtn000 = new ASTPropertyList(JJTPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropertyList */
    try {
/*@egen*/
    Verb() ObjectList() [ <SEMICOLON> [PropertyList()] ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TriplesNode()       :
{}
{
    Collection()
|
    BlankNodePropertyList()
}

void Var() :
{/*@bgen(jjtree) Var */
  ASTVar jjtn000 = new ASTVar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Var */
    try {
/*@egen*/
    ( t = <VAR1> | t = <VAR2> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.setName(t.image.substring(1)); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GraphTerm()       :
{
    boolean positive = true;
}
{
    IRIref()
|
    RDFLiteral()
|
    NumericLiteral()
|
    BooleanLiteral()
|
    BlankNode()
|
    <NIL>/*@bgen(jjtree) IRI */
          {
            ASTIRI jjtn001 = new ASTIRI(JJTIRI);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*//*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn001, true);
            jjtc001 = false;
          }
/*@egen*/ {jjtn001.setValue(RDF.NIL.toString());}/*@bgen(jjtree)*/
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/     
}

void Verb()       :
{}
{
    VarOrIRIref()
|
    <IS_A>/*@bgen(jjtree) IRI */
           {
             ASTIRI jjtn001 = new ASTIRI(JJTIRI);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*//*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn001, true);
             jjtc001 = false;
           }
/*@egen*/ { jjtn001.setValue(RDF.TYPE.toString()); }/*@bgen(jjtree)*/
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/     
}

void ObjectList():
{/*@bgen(jjtree) ObjectList */
  ASTObjectList jjtn000 = new ASTObjectList(JJTOBJECTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectList */
    try {
/*@egen*/
    Object() ( <COMMA> Object() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Collection() :
{/*@bgen(jjtree) Collection */
  ASTCollection jjtn000 = new ASTCollection(JJTCOLLECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Collection */
    try {
/*@egen*/
    <LPAREN> ( GraphNode() )+ <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BlankNodePropertyList() :
{/*@bgen(jjtree) BlankNodePropertyList */
  ASTBlankNodePropertyList jjtn000 = new ASTBlankNodePropertyList(JJTBLANKNODEPROPERTYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BlankNodePropertyList */
    try {
/*@egen*/
    <LBRACK> PropertyList() <RBRACK>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarOrIRIref()       :
{}
{
    Var()
|
    IRIref()
}

void Object()       :
{}
{
    GraphNode()
}

void GraphNode()       :
{}
{
    VarOrTerm()
|
    TriplesNode()
}

void IRIref()       :
{}
{
    IRI()
|
    PrefixedName()
}

void PrefixedName()        :
{/*@bgen(jjtree) QName */
  ASTQName jjtn000 = new ASTQName(JJTQNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) QName */
    try {
/*@egen*/
    (t = <PNAME_LN> | t = <PNAME_NS>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BlankNode() :
{/*@bgen(jjtree) BlankNode */
  ASTBlankNode jjtn000 = new ASTBlankNode(JJTBLANKNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BlankNode */
    try {
/*@egen*/
    t = <BLANK_NODE_LABEL>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {jjtn000.setID(t.image.substring(2));}
|
    <ANON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IRI() :
{/*@bgen(jjtree) IRI */
  ASTIRI jjtn000 = new ASTIRI(JJTIRI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IRI */
    try {
/*@egen*/
    t = <Q_IRI_REF>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setValue(_trimString(t.image, 1));}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Literals

void RDFLiteral() :
{/*@bgen(jjtree) RDFLiteral */
  ASTRDFLiteral jjtn000 = new ASTRDFLiteral(JJTRDFLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RDFLiteral */
    try {
/*@egen*/
    String()
    [
        t = <LANGTAG> {jjtn000.setLang(t.image.substring(1));}
    |
        <DT_PREFIX> IRIref()
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteral()       :
{}
{
    (
        NumericLiteralUnsigned()
    |   NumericLiteralPositive()
    |   NumericLiteralNegative()
    )
}

void NumericLiteralUnsigned()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteralPositive()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER_POSITIVE> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL_POSITIVE> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE_POSITIVE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumericLiteralNegative()                 :
{/*@bgen(jjtree) NumericLiteral */
  ASTNumericLiteral jjtn000 = new ASTNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; URI datatype; }
{/*@bgen(jjtree) NumericLiteral */
    try {
/*@egen*/
    (
        t = <INTEGER_NEGATIVE> { datatype = XMLSchema.INTEGER; }
    |   t = <DECIMAL_NEGATIVE> { datatype = XMLSchema.DECIMAL; }
    |   t = <DOUBLE_NEGATIVE> { datatype = XMLSchema.DOUBLE; }
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.setValue(t.image);
        jjtn000.setDatatype(datatype);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BooleanLiteral()       :
{}
{/*@bgen(jjtree) True */
    {
      ASTTrue jjtn001 = new ASTTrue(JJTTRUE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/      
|/*@bgen(jjtree) False */
    {
      ASTFalse jjtn002 = new ASTFalse(JJTFALSE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/   <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/       
}

void String() :
{/*@bgen(jjtree) String */
  ASTString jjtn000 = new ASTString(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) String */
    try {
/*@egen*/
    ( t = <STRING_LITERAL1> | t= <STRING_LITERAL2> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(_trimString(t.image, 1));}
|
    ( t = <STRING_LITERAL_LONG1> | t = <STRING_LITERAL_LONG2>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setValue(_trimString(t.image, 3));}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


